#!/bin/bash

set -uo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Test counters
TOTAL_TESTS=0
PASSED_TESTS=0
FAILED_TESTS=0

# Test directory
TEST_DIR="/tmp/gs_test_$$"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

# Cleanup function
cleanup() {
    rm -rf "$TEST_DIR"
}

# Trap cleanup on exit
trap cleanup EXIT

# Print colored output
print_status() {
    local status="$1"
    local message="$2"
    case "$status" in
        "PASS") echo -e "${GREEN}✓ PASS${NC}: $message" ;;
        "FAIL") echo -e "${RED}✗ FAIL${NC}: $message" ;;
        "INFO") echo -e "${BLUE}ℹ INFO${NC}: $message" ;;
        "WARN") echo -e "${YELLOW}⚠ WARN${NC}: $message" ;;
    esac
}

# Test assertion function
assert_equal() {
    local expected="$1"
    local actual="$2"
    local test_name="$3"

    ((TOTAL_TESTS++))

    if [[ "$expected" == "$actual" ]]; then
        print_status "PASS" "$test_name"
        ((PASSED_TESTS++))
        return 0
    else
        print_status "FAIL" "$test_name"
        echo "  Expected: '$expected'"
        echo "  Actual  : '$actual'"
        ((FAILED_TESTS++))
        return 1
    fi
}

# Test file content assertion
assert_file_content() {
    local expected="$1"
    local file="$2"
    local test_name="$3"

    ((TOTAL_TESTS++))

    if [[ -f "$file" ]]; then
        local actual
        actual=$(cat "$file")
        if [[ "$expected" == "$actual" ]]; then
            print_status "PASS" "$test_name"
            ((PASSED_TESTS++))
            return 0
        else
            print_status "FAIL" "$test_name"
            echo "  Expected content: '$expected'"
            echo "  Actual content  : '$actual'"
            ((FAILED_TESTS++))
            return 1
        fi
    else
        print_status "FAIL" "$test_name (file not found)"
        ((FAILED_TESTS++))
        return 1
    fi
}

# Setup test environment
setup_test_env() {
    mkdir -p "$TEST_DIR"
    cd "$TEST_DIR"

    # Create test files with known content
    echo "hello world" > "test1.txt"
    echo "function test() { return 42; }" > "test2.js"
    echo "var oldVar = 'value';" > "test3.js"
    echo "2023-12-25 Christmas" > "dates.txt"

    print_status "INFO" "Test environment created in $TEST_DIR"
}

# Test basic search functionality
test_search_basic() {
    print_status "INFO" "Testing basic search functionality..."

    # Test simple search
    local output
    output=$("$SCRIPT_DIR/g" "hello" . 2>&1)
    if echo "$output" | grep -q "test1.txt"; then
        print_status "PASS" "Basic search finds correct file"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Basic search failed"
        echo "Output: $output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Test no matches
    local no_match_output
    no_match_output=$("$SCRIPT_DIR/g" "nonexistent" . 2>&1)
    if echo "$no_match_output" | grep -q "No matches found"; then
        print_status "PASS" "No matches correctly reported"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "No matches not handled correctly"
        echo "Output: $no_match_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test basic replacement functionality
test_replace_basic() {
    print_status "INFO" "Testing basic replacement functionality..."

    # Test simple replacement
    local original_content
    original_content=$(cat test1.txt)

    # Run replacement (no confirmation needed)
    "$SCRIPT_DIR/s" "hello" "hi" . >/dev/null 2>&1

    local new_content
    new_content=$(cat test1.txt)

    assert_equal "hi world" "$new_content" "Simple text replacement works"

    # Restore for next test
    echo "$original_content" > test1.txt
}

# Test regex replacement
test_replace_regex() {
    print_status "INFO" "Testing regex replacement functionality..."

    # Test word boundary replacement
    local original_content
    original_content=$(cat test3.js)

    # Run regex replacement
    "$SCRIPT_DIR/s" '\bvar\b' 'let' . >/dev/null 2>&1

    local new_content
    new_content=$(cat test3.js)

    assert_equal "let oldVar = 'value';" "$new_content" "Regex word boundary replacement works"

    # Restore
    echo "$original_content" > test3.js
}

# Test capture groups
test_replace_capture_groups() {
    print_status "INFO" "Testing capture group replacement..."

    # Test capture groups with date format
    local original_dates
    original_dates=$(cat dates.txt)

    # Replace YYYY-MM-DD with DD/MM/YYYY
    "$SCRIPT_DIR/s" '([0-9]{4})-([0-9]{2})-([0-9]{2})' '$3/$2/$1' . >/dev/null 2>&1

    local new_dates
    new_dates=$(cat dates.txt)

    assert_equal "25/12/2023 Christmas" "$new_dates" "Capture group replacement works"

    # Restore
    echo "$original_dates" > dates.txt
}

# Test dry-run functionality
test_dry_run() {
    print_status "INFO" "Testing dry-run functionality..."

    local original_content
    original_content=$(cat test1.txt)

    # Run dry-run
    local dry_run_output
    dry_run_output=$("$SCRIPT_DIR/s" "world" "universe" . --dry-run 2>&1)

    # Check that dry-run was indicated
    if echo "$dry_run_output" | grep -q "DRY RUN"; then
        print_status "PASS" "Dry-run mode activated"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Dry-run mode not indicated"
        echo "Output: $dry_run_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Check file was not modified
    local after_dry_run
    after_dry_run=$(cat test1.txt)

    assert_equal "$original_content" "$after_dry_run" "Dry-run preserves original file"
}

# Test error handling
test_error_handling() {
    print_status "INFO" "Testing error handling..."

    # Test empty pattern
    local empty_pattern_output
    empty_pattern_output=$("$SCRIPT_DIR/g" "" . 2>&1) && local empty_exit_code=0 || local empty_exit_code=$?

    if [[ $empty_exit_code -ne 0 ]]; then
        print_status "PASS" "Empty pattern rejected with non-zero exit code"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Empty pattern should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Test non-existent directory
    local bad_dir_output
    bad_dir_output=$("$SCRIPT_DIR/g" "test" "/nonexistent" 2>&1) && local bad_dir_exit=0 || local bad_dir_exit=$?

    if [[ $bad_dir_exit -ne 0 ]]; then
        print_status "PASS" "Non-existent directory rejected"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Non-existent directory should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test delete functionality (empty replacement)
test_delete_basic() {
    print_status "INFO" "Testing basic delete functionality..."

    # Create test file with content to delete
    echo "console.log('debug 1');" > delete_test.js
    echo "var x = 5;" >> delete_test.js
    echo "console.log('debug 2');" >> delete_test.js
    echo "let y = 10;" >> delete_test.js

    # Test basic deletion (console.log statements)
    "$SCRIPT_DIR/s" 'console\.log\(.*?\);?' '' . >/dev/null 2>&1

    local result_content
    result_content=$(cat delete_test.js)
    local expected_content=$'\nvar x = 5;\n\nlet y = 10;'

    assert_equal "$expected_content" "$result_content" "Delete console.log statements works"

    # Test deletion with trailing whitespace
    echo "line with spaces   " > whitespace_test.txt
    echo "clean line" >> whitespace_test.txt
    echo "another line with tabs	" >> whitespace_test.txt

    "$SCRIPT_DIR/s" '\s+$' '' . >/dev/null 2>&1

    local whitespace_result
    whitespace_result=$(cat whitespace_test.txt)
    local expected_whitespace=$'line with spaces\nclean line\nanother line with tabs'

    assert_equal "$expected_whitespace" "$whitespace_result" "Delete trailing whitespace works"
}

# Test delete dry-run functionality
test_delete_dry_run() {
    print_status "INFO" "Testing delete dry-run functionality..."

    # Create test file
    echo "remove this text" > delete_dry_test.txt
    echo "keep this line" >> delete_dry_test.txt
    echo "remove this text too" >> delete_dry_test.txt

    local original_content
    original_content=$(cat delete_dry_test.txt)

    # Run dry-run deletion
    local dry_run_output
    dry_run_output=$("$SCRIPT_DIR/s" "remove this text.*" '' . --dry-run 2>&1)

    # Check that dry-run was indicated
    if echo "$dry_run_output" | grep -q "DRY RUN"; then
        print_status "PASS" "Delete dry-run mode activated"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Delete dry-run mode not indicated"
        echo "Output: $dry_run_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Check file was not modified
    local after_dry_run
    after_dry_run=$(cat delete_dry_test.txt)

    assert_equal "$original_content" "$after_dry_run" "Delete dry-run preserves original file"

    # Check that dry-run shows deletion correctly
    if echo "$dry_run_output" | grep -q "\-.*remove this text"; then
        print_status "PASS" "Delete dry-run shows removal correctly"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Delete dry-run does not show removal correctly"
        echo "Output: $dry_run_output"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test complex delete patterns
test_delete_complex_patterns() {
    print_status "INFO" "Testing complex delete patterns..."

    # Test multi-line comment deletion
    cat > comment_test.js << 'EOF'
// Single line comment
var x = 1;
/* Multi-line
   comment block */
var y = 2;
/* Another comment */
var z = 3;
EOF

    # Delete single-line comments
    "$SCRIPT_DIR/s" '//.*$' '' . >/dev/null 2>&1

    local after_single_comments
    after_single_comments=$(cat comment_test.js)

    # Should not contain // comments
    if ! echo "$after_single_comments" | grep -q "//"; then
        print_status "PASS" "Single-line comment deletion works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single-line comment deletion failed"
        echo "Content: $after_single_comments"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Test URL pattern deletion
    cat > url_test.txt << 'EOF'
Visit https://example.com for more info
Email: test@example.com
Also check http://test.org
Normal text here
EOF

    # Delete URLs
    "$SCRIPT_DIR/s" 'https?://[^\s]+' '' . >/dev/null 2>&1

    local after_urls
    after_urls=$(cat url_test.txt)
    local expected_after_urls=$'Visit  for more info\nEmail: test@example.com\nAlso check \nNormal text here'

    assert_equal "$expected_after_urls" "$after_urls" "URL deletion works"
}

# Test successful exit codes
test_exit_codes() {
    print_status "INFO" "Testing exit codes..."

    # Test successful replacement returns 0
    echo "test content" > exit_test.txt
    "$SCRIPT_DIR/s" "test" "example" . >/dev/null 2>&1
    local success_exit=$?

    assert_equal "0" "$success_exit" "Successful replacement returns exit code 0"

    # Test successful search returns 0
    "$SCRIPT_DIR/g" "example" . >/dev/null 2>&1
    local search_exit=$?

    assert_equal "0" "$search_exit" "Successful search returns exit code 0"
}

# Main test runner
main() {
    echo "==========================================="
    echo "  Testing G/S Search and Replace Tools"
    echo "==========================================="
    echo ""

    # Check if tools exist
    if [[ ! -f "$SCRIPT_DIR/g" ]] || [[ ! -f "$SCRIPT_DIR/s" ]]; then
        print_status "FAIL" "Tools g and s not found in $SCRIPT_DIR"
        exit 1
    fi

    print_status "INFO" "Tools found: $SCRIPT_DIR/g, $SCRIPT_DIR/s"

    # Setup test environment
    setup_test_env

    # Run all tests
    test_search_basic
    test_replace_basic
    test_replace_regex
    test_replace_capture_groups
    test_dry_run
    test_delete_basic
    test_delete_dry_run
    test_delete_complex_patterns
    test_error_handling
    test_exit_codes
    test_single_file_operations
    test_single_file_error_handling

    # Print summary
    echo ""
    echo "==========================================="
    echo "  Test Summary"
    echo "==========================================="
    echo "Total tests: $TOTAL_TESTS"
    echo -e "Passed: ${GREEN}$PASSED_TESTS${NC}"
    echo -e "Failed: ${RED}$FAILED_TESTS${NC}"

    if [[ $FAILED_TESTS -eq 0 ]]; then
        echo -e "\n${GREEN}All tests passed!${NC}"
        exit 0
    else
        echo -e "\n${RED}Some tests failed!${NC}"
        exit 1
    fi
}

# Test single file functionality
test_single_file_operations() {
    print_status "INFO" "Testing single file operations..."

    # Create a test file
    echo "single file content for testing" > single_test.txt
    echo "another line with pattern" >> single_test.txt

    # Test single file search
    local search_output
    search_output=$("$SCRIPT_DIR/g" "pattern" single_test.txt 2>/dev/null)
    if echo "$search_output" | grep -q "pattern"; then
        print_status "PASS" "Single file search works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file search failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Test single file replacement
    "$SCRIPT_DIR/s" "pattern" "replacement" single_test.txt >/dev/null 2>&1
    local file_content
    file_content=$(cat single_test.txt)

    if echo "$file_content" | grep -q "replacement"; then
        print_status "PASS" "Single file replacement works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file replacement failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Test single file dry-run
    echo "dry run test content" > dry_run_single.txt
    local dry_run_output
    dry_run_output=$("$SCRIPT_DIR/s" "test" "modified" dry_run_single.txt --dry-run 2>/dev/null)

    if echo "$dry_run_output" | grep -q "DRY RUN"; then
        print_status "PASS" "Single file dry-run works"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Single file dry-run failed"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))

    # Verify dry-run didn't change file
    local original_content
    original_content=$(cat dry_run_single.txt)
    if [[ "$original_content" == "dry run test content" ]]; then
        print_status "PASS" "Dry-run preserves file content"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Dry-run modified file content"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Test single file error handling
test_single_file_error_handling() {
    print_status "INFO" "Testing single file error handling..."

    # Test non-existent file
    local nonexistent_output
    nonexistent_output=$("$SCRIPT_DIR/s" "test" "replacement" "/nonexistent/file.txt" 2>&1) && local nonexistent_exit=0 || local nonexistent_exit=$?

    if [[ $nonexistent_exit -ne 0 ]]; then
        print_status "PASS" "Non-existent file rejected"
        ((PASSED_TESTS++))
    else
        print_status "FAIL" "Non-existent file should be rejected"
        ((FAILED_TESTS++))
    fi
    ((TOTAL_TESTS++))
}

# Run main function
main "$@"

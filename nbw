#!/bin/bash

# Unified new branch script for both work and hobby projects
# Usage: nb [--work|-w] <ticket_number> [suffix]
#        nb [--help|-h]

# Source common git functions
if [[ -f "$(dirname "$0")/git-common.sh" ]]; then
    source "$(dirname "$0")/git-common.sh"
fi

# Source repo prefix function (for hobby projects)
if [[ -f ~/my-config-files/bash.functions ]]; then
    source ~/my-config-files/bash.functions
fi

# Function to show usage
show_usage() {
    cat << EOF
Usage: $0 [OPTIONS] <ticket_number> [suffix]

Create a new feature branch from the best available base branch.

OPTIONS:
    -w, --work      Use work project prefix (mt)
    -h, --help      Show this help message

ARGUMENTS:
    ticket_number   The ticket/issue number for the branch
    suffix          Optional suffix for the branch name

FILE NAME SHORTCUTS:
    nbw <ticket>    # Auto work mode: feature/mt-<ticket>
    nbh <ticket>    # Auto hobby mode: feature/<project>-<ticket>
    nb <ticket>     # Default hobby mode (use -w for work)

EXAMPLES:
    nb 123              # hobby project: feature/myproject-123
    nb --work 456       # work project: feature/mt-456  
    nbw 789             # work project: feature/mt-789
    nbh 101 bugfix      # hobby project: feature/myproject-101-bugfix

The script automatically:
- Fetches latest changes from remote
- Finds the best base branch (integration > main > master)
- Checks for uncommitted changes before switching
- Creates and switches to the new feature branch

EOF
}

# Function to get repository prefix for hobby projects
get_repo_prefix_fallback() {
    # Fallback implementation if bash.functions is not available
    local repo_name=$(basename "$(git rev-parse --show-toplevel)" 2>/dev/null)
    if [[ -n "$repo_name" ]]; then
        echo "$repo_name"
    else
        echo "project"
    fi
}

# Function to create a new branch from given base
create_branch() {
    local base_branch=$1
    local use_origin=$2
    local is_work_mode=$3
    local ticket_number=$4
    local suffix=$5
    
    # Check for uncommitted changes (in all modes for safety)
    if command -v check_uncommitted_changes &>/dev/null; then
        check_uncommitted_changes
    fi
    
    # Determine prefix
    local prefix
    if [[ "$is_work_mode" == "true" ]]; then
        prefix="mt"
    else
        if command -v get_repo_prefix &>/dev/null; then
            prefix=$(get_repo_prefix)
        else
            prefix=$(get_repo_prefix_fallback)
        fi
    fi
    
    # Build suffix string
    local suffix_str=""
    [[ -n "$suffix" ]] && suffix_str="-$suffix"
    
    # Determine the base reference
    local base_ref
    if [[ "$use_origin" == "true" ]]; then
        base_ref="origin/$base_branch"
    else
        base_ref="$base_branch"
    fi
    
    # Create the branch name
    local branch_name="feature/$prefix-$ticket_number$suffix_str"
    
    # Run git checkout to create and switch to a new branch
    checkout_output=$(git checkout -b "$branch_name" "$base_ref" 2>&1)
    exit_code=$?
    
    # Print the git output, append base info only on success
    if [[ $exit_code -eq 0 ]]; then
        echo "$checkout_output (from: $base_ref)"
    else
        echo "$checkout_output"
    fi
    exit $exit_code
}

# Detect mode based on script name
script_name=$(basename "$0")
is_work_mode=false

case "$script_name" in
    "nbw")
        is_work_mode=true
        ;;
    "nbh")
        is_work_mode=false
        ;;
    *)
        # Default behavior for 'nb' - can be overridden by --work flag
        is_work_mode=false
        ;;
esac

# Parse command line arguments
ticket_number=""
suffix=""

while [[ $# -gt 0 ]]; do
    case $1 in
        -w|--work)
            is_work_mode=true
            shift
            ;;
        -h|--help)
            show_usage
            exit 0
            ;;
        -*)
            echo "Error: Unknown option $1"
            show_usage
            exit 1
            ;;
        *)
            if [[ -z "$ticket_number" ]]; then
                ticket_number="$1"
            elif [[ -z "$suffix" ]]; then
                suffix="$1"
            else
                echo "Error: Too many arguments"
                show_usage
                exit 1
            fi
            shift
            ;;
    esac
done

# Validate required arguments
if [[ -z "$ticket_number" ]]; then
    echo "Error: ticket_number is required"
    show_usage
    exit 1
fi

# Check if the current directory is a git repository
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Current directory is not a git repository."
    exit 1
fi

# Run git fetch to get the latest changes from the remote repository
git fetch

# Define preferred base branches (integration has highest priority)
preferred_branches=("integration" "main" "master")
base_branch_found=""
available_branches=()

# Check all preferred branches and collect available ones
for branch_name in "${preferred_branches[@]}"; do
    if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
        available_branches+=("$branch_name")
        # Use the first available branch (highest priority)
        if [[ -z "$base_branch_found" ]]; then
            base_branch_found="$branch_name"
        fi
    fi
done

# If a preferred branch is found, use it
if [[ -n "$base_branch_found" ]]; then
    # Show which branches are available and which one is being used
    if [[ ${#available_branches[@]} -gt 1 ]]; then
        echo "Available base branches: ${available_branches[*]}"
        echo "Using highest priority base branch: origin/$base_branch_found"
    else
        echo "Using base branch: origin/$base_branch_found"
    fi
    create_branch "$base_branch_found" "true" "$is_work_mode" "$ticket_number" "$suffix"
else
    echo "Error: None of the preferred base branches (origin/integration, origin/main, origin/master) were found."
    exit 1
fi

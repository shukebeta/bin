#!/bin/bash

# Source common git functions
source "$(dirname "$0")/git-common.sh"

# Function to create a new branch from given base
create_branch() {
    local base_branch=$1
    local use_origin=$2

    # Check for uncommitted changes before creating new branch
    check_uncommitted_changes

    # Check if correct number of arguments is provided
    if [[ $# -eq 3 ]] || [[ $# -eq 4 ]]; then
        # Set suffix if provided
        local suffix=""
        [[ $# -eq 4 ]] && suffix="-$4"

        # Determine the base reference
        local base_ref
        if [[ "$use_origin" == "true" ]]; then
            base_ref="origin/$base_branch"
        else
            base_ref="$base_branch"
        fi

        # Run git checkout to create and switch to a new branch
        checkout_output=$(git checkout -b "feature/mt-$3$suffix" "$base_ref" 2>&1)
        exit_code=$?

        # Print the git output, append base info only on success
        if [[ $exit_code -eq 0 ]]; then
            echo "$checkout_output (from: $base_ref)"
        else
            echo "$checkout_output"
        fi
        exit $exit_code
    else
        echo "Usage: $0 <anumber> [suffix]"
        exit 1
    fi
}

# Check if the current directory is a git repository
if ! git rev-parse --is-inside-work-tree &>/dev/null; then
    echo "Error: Current directory is not a git repository."
    exit 1
fi

# Run git fetch to get the latest changes from the remote repository
git fetch

# Detect how the script was called
script_name=$(basename "$0")

if [[ "$script_name" == "nbc" ]]; then
    # Use current branch as base
    current_branch=$(git branch --show-current)
    if [[ -z "$current_branch" ]]; then
        echo "Error: Could not determine current branch."
        exit 1
    fi
    create_branch "$current_branch" "false" "$@"
else
    # Original nb behavior: use preferred remote branches
    # Integration has highest priority, then main, then master
    preferred_branches=("integration" "main" "master")
    base_branch_found=""
    available_branches=()

    # Check all preferred branches and collect available ones
    for branch_name in "${preferred_branches[@]}"; do
        if git show-ref --verify --quiet "refs/remotes/origin/$branch_name"; then
            available_branches+=("$branch_name")
            # Use the first available branch (highest priority)
            if [[ -z "$base_branch_found" ]]; then
                base_branch_found="$branch_name"
            fi
        fi
    done

    # If a preferred branch is found, use it
    if [[ -n "$base_branch_found" ]]; then
        # Show which branches are available and which one is being used
        if [[ ${#available_branches[@]} -gt 1 ]]; then
            echo "Available base branches: ${available_branches[*]}"
            echo "Using highest priority base branch: origin/$base_branch_found"
        else
            echo "Using base branch: origin/$base_branch_found"
        fi
        create_branch "$base_branch_found" "true" "$@"
    else
        echo "Error: None of the preferred base branches (origin/integration, origin/main, origin/master) were found."
        exit 1
    fi
fi
